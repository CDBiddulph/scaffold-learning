<metadata>
    <created_at>2025-07-14T14:02:16.495543</created_at>
    <executor_prompt>&lt;scoring_function&gt;```python
import re


def score(expected_solution, attempted_solution):
    """
    Score a puzzle answer against the solution.

    Args:
        expected_solution: String containing the expected solution (like from JSONL "solution" field)
        attempted_solution: String containing the attempted solution

    Returns:
        float: Score from 0.0 to 1.0 representing percentage of correct squares
    """
    # Parse expected solution into sections
    expected_grid, expected_across, expected_down = _parse_expected_solution(
        expected_solution
    )

    # If attempted solution is empty, score is 0.0
    content = attempted_solution.strip()
    if not content:
        return 0.0, 0, 0

    # Split by double newlines to get pieces
    pieces = content.split("\n\n")
    if not pieces or all(not piece.strip() for piece in pieces):
        return 0.0, 0, 0

    # Track correctness of each fillable square by position in grid
    # We'll use row,col coordinates since that's easier to work with
    width = len(expected_grid[0]) if expected_grid else 0
    height = len(expected_grid)

    if width == 0 or height == 0:
        return 0.0, 0, 0

    # Track which squares are correct/incorrect
    correct_squares = set()
    incorrect_squares = set()

    # Process each piece
    for piece in pieces:
        piece = piece.strip()
        if not piece:
            continue

        if piece.startswith("Across:"):
            _process_across_section(
                piece,
                expected_across,
                width,
                expected_grid,
                correct_squares,
                incorrect_squares,
            )
        elif piece.startswith("Down:"):
            _process_down_section(
                piece,
                expected_down,
                height,
                expected_grid,
                correct_squares,
                incorrect_squares,
            )
        else:
            # Assume it's a grid
            _process_grid_section(
                piece, expected_grid, correct_squares, incorrect_squares
            )

    # Count fillable squares and determine final correct squares
    fillable_count = 0
    final_correct_squares = set()

    for row in range(height):
        for col in range(width):
            if expected_grid[row][col] != ".":  # Not a black square
                fillable_count += 1
                pos = (row, col)
                if pos in correct_squares and pos not in incorrect_squares:
                    final_correct_squares.add(pos)

    correct_count = len(final_correct_squares)

    # Calculate score
    if fillable_count == 0:
        return 0.0, 0, 0

    score = correct_count / fillable_count
    return score, correct_count, fillable_count


def _parse_expected_solution(expected_solution):
    """Parse expected solution into grid, across clues, and down clues"""
    lines = expected_solution.strip().split("\n")

    # Extract grid
    grid_lines = []
    line_idx = 0
    while line_idx &lt; len(lines):
        line = lines[line_idx].strip()
        if not line or line.startswith("Across:") or line.startswith("Down:"):
            break
        grid_lines.append(line.split())
        line_idx += 1

    # Extract clues
    across_clues = {}
    down_clues = {}

    current_section = None
    for i in range(line_idx, len(lines)):
        line = lines[i].strip()
        if line.startswith("Across:"):
            current_section = "across"
        elif line.startswith("Down:"):
            current_section = "down"
        elif line and current_section:
            # Parse clue line
            match = re.match(r"\s*(\d+)\.\s*(.+)", line)
            if match:
                clue_num = int(match.group(1))
                answer = match.group(2).strip().upper()
                if current_section == "across":
                    across_clues[clue_num] = answer
                else:
                    down_clues[clue_num] = answer

    return grid_lines, across_clues, down_clues


def _process_grid_section(grid_text, expected_grid, correct_squares, incorrect_squares):
    """Process a grid format piece"""
    lines = grid_text.strip().split("\n")
    height = len(expected_grid)
    width = len(expected_grid[0]) if height &gt; 0 else 0

    for row_idx, line in enumerate(lines):
        if row_idx &gt;= height:
            break

        cells = line.split()
        for col_idx, cell in enumerate(cells):
            if col_idx &gt;= width:
                break

            expected = expected_grid[row_idx][col_idx].upper()
            actual = cell.upper()
            pos = (row_idx, col_idx)

            # Skip black squares
            if expected == ".":
                continue

            # Mark square as correct or incorrect
            if actual == expected:
                correct_squares.add(pos)
            else:
                incorrect_squares.add(pos)


def _process_across_section(
    section_text,
    expected_across,
    width,
    expected_grid,
    correct_squares,
    incorrect_squares,
):
    """Process an Across: section"""
    lines = section_text.split("\n")[1:]  # Skip the "Across:" line

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # Parse clue number and answer
        match = re.match(r"\s*(\d+)\.\s*(.+)", line)
        if not match:
            continue

        clue_num = int(match.group(1))
        answer = match.group(2).strip().upper()

        # Find where this clue should be in the expected solution
        if clue_num not in expected_across:
            continue

        expected_answer = expected_across[clue_num]

        # Find the position of this clue in the grid
        clue_pos = _find_clue_position(clue_num, expected_grid, "across")
        if clue_pos is None:
            continue

        row, col = clue_pos

        # Check each letter of the answer
        for i, letter in enumerate(answer):
            if col + i &gt;= width or i &gt;= len(expected_answer):
                break

            pos = (row, col + i)
            expected_letter = expected_answer[i].upper()

            # Skip black squares
            if expected_grid[row][col + i] == ".":
                continue

            # Mark square as correct or incorrect
            if letter == expected_letter:
                correct_squares.add(pos)
            else:
                incorrect_squares.add(pos)


def _process_down_section(
    section_text,
    expected_down,
    height,
    expected_grid,
    correct_squares,
    incorrect_squares,
):
    """Process a Down: section"""
    lines = section_text.split("\n")[1:]  # Skip the "Down:" line

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # Parse clue number and answer
        match = re.match(r"\s*(\d+)\.\s*(.+)", line)
        if not match:
            continue

        clue_num = int(match.group(1))
        answer = match.group(2).strip().upper()

        # Find where this clue should be in the expected solution
        if clue_num not in expected_down:
            continue

        expected_answer = expected_down[clue_num]

        # Find the position of this clue in the grid
        clue_pos = _find_clue_position(clue_num, expected_grid, "down")
        if clue_pos is None:
            continue

        row, col = clue_pos

        # Check each letter of the answer
        for i, letter in enumerate(answer):
            if row + i &gt;= height or i &gt;= len(expected_answer):
                break

            pos = (row + i, col)
            expected_letter = expected_answer[i].upper()

            # Skip black squares
            if expected_grid[row + i][col] == ".":
                continue

            # Mark square as correct or incorrect
            if letter == expected_letter:
                correct_squares.add(pos)
            else:
                incorrect_squares.add(pos)


def _find_clue_position(clue_num, grid, direction):
    """Find the starting position of a clue in the grid based on numbering logic"""
    height = len(grid)
    width = len(grid[0]) if height &gt; 0 else 0

    current_num = 1

    for row in range(height):
        for col in range(width):
            # Skip black squares
            if grid[row][col] == ".":
                continue

            # Check if this position starts a word
            starts_across = (
                (col == 0 or grid[row][col - 1] == ".")
                and col + 1 &lt; width
                and grid[row][col + 1] != "."
            )
            starts_down = (
                (row == 0 or grid[row - 1][col] == ".")
                and row + 1 &lt; height
                and grid[row + 1][col] != "."
            )

            if starts_across or starts_down:
                if current_num == clue_num:
                    return (row, col)
                current_num += 1

    return None

```&lt;/scoring_function&gt;
&lt;example-1&gt;
    &lt;input&gt;- - - - . - - - - - . - - - -
- - - - . - - - - - . - - - -
- - - - - - - - - - . - - - -
- - - - - . - - - . - - - - -
- - - - - - . - - - - - - - -
- - - - - - - . - - - - - - .
- - - . . - - - . - - - - . .
. . . - - - - - - - - - . . .
. . - - - - . - - - . . - - -
. - - - - - - . - - - - - - -
- - - - - - - - . - - - - - -
- - - - - . - - - . - - - - -
- - - - . - - - - - - - - - -
- - - - . - - - - - . - - - -
- - - - . - - - - - . - - - -

Across:
  1. Make reference to
  5. Person with a twisted mind
 10. Uncomfortable health class subject, for short
 14. Onetime "Jeopardy!" host Trebek
 15. Stared creepily
 16. Dorito, e.g.
 17. Obsolescent classroom wall fixture
 19. Give a makeover
 20. Gone up
 21. Drink of choice for Captain Jack Sparrow
 22. Martial art that uses bamboo swords
 23. Chilly treat
 25. Hopscotch locale
 27. Slimeball
 29. Rather warm, as a firelit room
 30. U.F.O. crew
 31. Mouse's bigger cousin
 33. Burden
 34. Achieved, as a victory ... or how you might describe 17-, 25-, 47 and 55-Across
 37. Stadium chants
 38. "Wise" bird
 39. Brand of motor oil
 42. Frog sounds
 44. Name on dictionaries
 47. Need for playing pool
 49. Overthrow
 50. Slender instruments
 51. Female name that's a body part spelled backward
 53. Strategically taps the ball into the infield
 54. Slimming surgery, for short
 55. Recreational rock climbers
 57. "Q ___ queen"
 58. "Remember the ___!"
 59. "___ dat"
 60. Captain Hook's right-hand man
 61. Poet whose first two initials stand for "Thomas" and "Stearns"
 62. IDs written on applications, for short

Down:
  1. Trip in a taxi
  2. Not allowed
  3. Enticing ad promotions
  4. Besides
  5. Weep loudly
  6. Lab assistant often depicted with a hunched back
  7. Name on a mailbox at the North Pole
  8. ___ the Frog
  9. Abnormal
 10. Makes an oopsie
 11. Washington's M.L.B. team, informally
 12. ___-squat (a whole lot of nothing)
 13. Give the heebie-jeebies
 18. Door opener
 22. Reeves of "The Matrix"
 24. Go down the slopes with a chute
 26. Drew funny little pictures
 28. Lass
 32. One end to a boxing match, for short
 34. "Phew!"
 35. Warms up
 36. "Gro-o-oss!"
 37. Black-and-white dessert that's sliced
 39. Pot smokers
 40. Experimental effort
 41. Pushes down, as with the thumb
 42. Style for Picasso
 43. Use TikTok, say
 45. Spanish newborn
 46. Small gushes
 47. Coke and Pepsi, but not Sprite
 48. Oahu neighbor
 52. Tickle Me ___
 55. Sweetie
 56. One of three in an ellipsis&lt;/input&gt;
    &lt;expected_output&gt;C I T E . S I C K O . S T D S
A L E X . O G L E D . C H I P
B L A C K B O A R D . R E D O
R I S E N . R U M . K E N D O
I C E P O P . S I D E W A L K
D I R T B A G . T O A S T Y .
E T S . . R A T . O N U S . .
. . . C H A L K E D U P . . .
. . O L E S . O W L . . S T P
. C R O A K S . W E B S T E R
C U E S T I C K . D E P O S E
O B O E S . R A E . B U N T S
L I P O . B O U L D E R E R S
A S I N . A L A M O . T R U E
S M E E . E L I O T . S S N S

Across:
  1. CITE
  5. SICKO
 10. STDS
 14. ALEX
 15. OGLED
 16. CHIP
 17. BLACKBOARD
 19. REDO
 20. RISEN
 21. RUM
 22. KENDO
 23. ICEPOP
 25. SIDEWALK
 27. DIRTBAG
 29. TOASTY
 30. ETS
 31. RAT
 33. ONUS
 34. CHALKEDUP
 37. OLES
 38. OWL
 39. STP
 42. CROAKS
 44. WEBSTER
 47. CUESTICK
 49. DEPOSE
 50. OBOES
 51. RAE
 53. BUNTS
 54. LIPO
 55. BOULDERERS
 57. ASIN
 58. ALAMO
 59. TRUE
 60. SMEE
 61. ELIOT
 62. SSNS

Down:
  1. CABRIDE
  2. ILLICIT
  3. TEASERS
  4. EXCEPT
  5. SOB
  6. IGOR
  7. CLAUS
  8. KERMIT
  9. ODD
 10. SCREWSUP
 11. THENATS
 12. DIDDLY
 13. SPOOK
 18. KNOB
 22. KEANU
 24. PARASKI
 26. DOODLED
 28. GAL
 32. TKO
 34. CLOSEONE
 35. HEATS
 36. EWW
 37. OREOPIE
 39. STONERS
 40. TESTRUN
 41. PRESSES
 42. CUBISM
 43. SCROLL
 45. BEBE
 46. SPURTS
 47. COLAS
 48. KAUAI
 52. ELMO
 55. BAE
 56. DOT&lt;/expected_output&gt;
&lt;/example-1&gt;

Your goal is to maximize your score on the input below.
Based on your output, you will get a score from 0 to 1.
In the example(s) above, returning &lt;expected-output&gt; would get you a score of 1.
Your exact response will be shown to the scorer, so don't add any extra information.

INPUT:
</executor_prompt>
</metadata>