from llm_executor import execute_llm

PROMPT = "<scoring_function>```python\nimport re\n\n\ndef score(expected_solution, attempted_solution):\n    \"\"\"\n    Score a puzzle answer against the solution.\n\n    Args:\n        expected_solution: String containing the expected solution (like from JSONL \"solution\" field)\n        attempted_solution: String containing the attempted solution\n\n    Returns:\n        float: Score from 0.0 to 1.0 representing percentage of correct squares\n    \"\"\"\n    # Parse expected solution into sections\n    expected_grid, expected_across, expected_down = _parse_expected_solution(\n        expected_solution\n    )\n\n    # If attempted solution is empty, score is 0.0\n    content = attempted_solution.strip()\n    if not content:\n        return 0.0, 0, 0\n\n    # Split by double newlines to get pieces\n    pieces = content.split(\"\\n\\n\")\n    if not pieces or all(not piece.strip() for piece in pieces):\n        return 0.0, 0, 0\n\n    # Track correctness of each fillable square by position in grid\n    # We'll use row,col coordinates since that's easier to work with\n    width = len(expected_grid[0]) if expected_grid else 0\n    height = len(expected_grid)\n\n    if width == 0 or height == 0:\n        return 0.0, 0, 0\n\n    # Track which squares are correct/incorrect\n    correct_squares = set()\n    incorrect_squares = set()\n\n    # Process each piece\n    for piece in pieces:\n        piece = piece.strip()\n        if not piece:\n            continue\n\n        if piece.startswith(\"Across:\"):\n            _process_across_section(\n                piece,\n                expected_across,\n                width,\n                expected_grid,\n                correct_squares,\n                incorrect_squares,\n            )\n        elif piece.startswith(\"Down:\"):\n            _process_down_section(\n                piece,\n                expected_down,\n                height,\n                expected_grid,\n                correct_squares,\n                incorrect_squares,\n            )\n        else:\n            # Assume it's a grid\n            _process_grid_section(\n                piece, expected_grid, correct_squares, incorrect_squares\n            )\n\n    # Count fillable squares and determine final correct squares\n    fillable_count = 0\n    final_correct_squares = set()\n\n    for row in range(height):\n        for col in range(width):\n            if expected_grid[row][col] != \".\":  # Not a black square\n                fillable_count += 1\n                pos = (row, col)\n                if pos in correct_squares and pos not in incorrect_squares:\n                    final_correct_squares.add(pos)\n\n    correct_count = len(final_correct_squares)\n\n    # Calculate score\n    if fillable_count == 0:\n        return 0.0, 0, 0\n\n    score = correct_count / fillable_count\n    return score, correct_count, fillable_count\n\n\ndef _parse_expected_solution(expected_solution):\n    \"\"\"Parse expected solution into grid, across clues, and down clues\"\"\"\n    lines = expected_solution.strip().split(\"\\n\")\n\n    # Extract grid\n    grid_lines = []\n    line_idx = 0\n    while line_idx < len(lines):\n        line = lines[line_idx].strip()\n        if not line or line.startswith(\"Across:\") or line.startswith(\"Down:\"):\n            break\n        grid_lines.append(line.split())\n        line_idx += 1\n\n    # Extract clues\n    across_clues = {}\n    down_clues = {}\n\n    current_section = None\n    for i in range(line_idx, len(lines)):\n        line = lines[i].strip()\n        if line.startswith(\"Across:\"):\n            current_section = \"across\"\n        elif line.startswith(\"Down:\"):\n            current_section = \"down\"\n        elif line and current_section:\n            # Parse clue line\n            match = re.match(r\"\\s*(\\d+)\\.\\s*(.+)\", line)\n            if match:\n                clue_num = int(match.group(1))\n                answer = match.group(2).strip().upper()\n                if current_section == \"across\":\n                    across_clues[clue_num] = answer\n                else:\n                    down_clues[clue_num] = answer\n\n    return grid_lines, across_clues, down_clues\n\n\ndef _process_grid_section(grid_text, expected_grid, correct_squares, incorrect_squares):\n    \"\"\"Process a grid format piece\"\"\"\n    lines = grid_text.strip().split(\"\\n\")\n    height = len(expected_grid)\n    width = len(expected_grid[0]) if height > 0 else 0\n\n    for row_idx, line in enumerate(lines):\n        if row_idx >= height:\n            break\n\n        cells = line.split()\n        for col_idx, cell in enumerate(cells):\n            if col_idx >= width:\n                break\n\n            expected = expected_grid[row_idx][col_idx].upper()\n            actual = cell.upper()\n            pos = (row_idx, col_idx)\n\n            # Skip black squares\n            if expected == \".\":\n                continue\n\n            # Mark square as correct or incorrect\n            if actual == expected:\n                correct_squares.add(pos)\n            else:\n                incorrect_squares.add(pos)\n\n\ndef _process_across_section(\n    section_text,\n    expected_across,\n    width,\n    expected_grid,\n    correct_squares,\n    incorrect_squares,\n):\n    \"\"\"Process an Across: section\"\"\"\n    lines = section_text.split(\"\\n\")[1:]  # Skip the \"Across:\" line\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n\n        # Parse clue number and answer\n        match = re.match(r\"\\s*(\\d+)\\.\\s*(.+)\", line)\n        if not match:\n            continue\n\n        clue_num = int(match.group(1))\n        answer = match.group(2).strip().upper()\n\n        # Find where this clue should be in the expected solution\n        if clue_num not in expected_across:\n            continue\n\n        expected_answer = expected_across[clue_num]\n\n        # Find the position of this clue in the grid\n        clue_pos = _find_clue_position(clue_num, expected_grid, \"across\")\n        if clue_pos is None:\n            continue\n\n        row, col = clue_pos\n\n        # Check each letter of the answer\n        for i, letter in enumerate(answer):\n            if col + i >= width or i >= len(expected_answer):\n                break\n\n            pos = (row, col + i)\n            expected_letter = expected_answer[i].upper()\n\n            # Skip black squares\n            if expected_grid[row][col + i] == \".\":\n                continue\n\n            # Mark square as correct or incorrect\n            if letter == expected_letter:\n                correct_squares.add(pos)\n            else:\n                incorrect_squares.add(pos)\n\n\ndef _process_down_section(\n    section_text,\n    expected_down,\n    height,\n    expected_grid,\n    correct_squares,\n    incorrect_squares,\n):\n    \"\"\"Process a Down: section\"\"\"\n    lines = section_text.split(\"\\n\")[1:]  # Skip the \"Down:\" line\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n\n        # Parse clue number and answer\n        match = re.match(r\"\\s*(\\d+)\\.\\s*(.+)\", line)\n        if not match:\n            continue\n\n        clue_num = int(match.group(1))\n        answer = match.group(2).strip().upper()\n\n        # Find where this clue should be in the expected solution\n        if clue_num not in expected_down:\n            continue\n\n        expected_answer = expected_down[clue_num]\n\n        # Find the position of this clue in the grid\n        clue_pos = _find_clue_position(clue_num, expected_grid, \"down\")\n        if clue_pos is None:\n            continue\n\n        row, col = clue_pos\n\n        # Check each letter of the answer\n        for i, letter in enumerate(answer):\n            if row + i >= height or i >= len(expected_answer):\n                break\n\n            pos = (row + i, col)\n            expected_letter = expected_answer[i].upper()\n\n            # Skip black squares\n            if expected_grid[row + i][col] == \".\":\n                continue\n\n            # Mark square as correct or incorrect\n            if letter == expected_letter:\n                correct_squares.add(pos)\n            else:\n                incorrect_squares.add(pos)\n\n\ndef _find_clue_position(clue_num, grid, direction):\n    \"\"\"Find the starting position of a clue in the grid based on numbering logic\"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n\n    current_num = 1\n\n    for row in range(height):\n        for col in range(width):\n            # Skip black squares\n            if grid[row][col] == \".\":\n                continue\n\n            # Check if this position starts a word\n            starts_across = (\n                (col == 0 or grid[row][col - 1] == \".\")\n                and col + 1 < width\n                and grid[row][col + 1] != \".\"\n            )\n            starts_down = (\n                (row == 0 or grid[row - 1][col] == \".\")\n                and row + 1 < height\n                and grid[row + 1][col] != \".\"\n            )\n\n            if starts_across or starts_down:\n                if current_num == clue_num:\n                    return (row, col)\n                current_num += 1\n\n    return None\n\n```</scoring_function>\n<example-1>\n    <input>- - - - . - - - - - . - - - -\n- - - - . - - - - - . - - - -\n- - - - - - - - - - . - - - -\n- - - - - . - - - . - - - - -\n- - - - - - . - - - - - - - -\n- - - - - - - . - - - - - - .\n- - - . . - - - . - - - - . .\n. . . - - - - - - - - - . . .\n. . - - - - . - - - . . - - -\n. - - - - - - . - - - - - - -\n- - - - - - - - . - - - - - -\n- - - - - . - - - . - - - - -\n- - - - . - - - - - - - - - -\n- - - - . - - - - - . - - - -\n- - - - . - - - - - . - - - -\n\nAcross:\n  1. Make reference to\n  5. Person with a twisted mind\n 10. Uncomfortable health class subject, for short\n 14. Onetime \"Jeopardy!\" host Trebek\n 15. Stared creepily\n 16. Dorito, e.g.\n 17. Obsolescent classroom wall fixture\n 19. Give a makeover\n 20. Gone up\n 21. Drink of choice for Captain Jack Sparrow\n 22. Martial art that uses bamboo swords\n 23. Chilly treat\n 25. Hopscotch locale\n 27. Slimeball\n 29. Rather warm, as a firelit room\n 30. U.F.O. crew\n 31. Mouse's bigger cousin\n 33. Burden\n 34. Achieved, as a victory ... or how you might describe 17-, 25-, 47 and 55-Across\n 37. Stadium chants\n 38. \"Wise\" bird\n 39. Brand of motor oil\n 42. Frog sounds\n 44. Name on dictionaries\n 47. Need for playing pool\n 49. Overthrow\n 50. Slender instruments\n 51. Female name that's a body part spelled backward\n 53. Strategically taps the ball into the infield\n 54. Slimming surgery, for short\n 55. Recreational rock climbers\n 57. \"Q ___ queen\"\n 58. \"Remember the ___!\"\n 59. \"___ dat\"\n 60. Captain Hook's right-hand man\n 61. Poet whose first two initials stand for \"Thomas\" and \"Stearns\"\n 62. IDs written on applications, for short\n\nDown:\n  1. Trip in a taxi\n  2. Not allowed\n  3. Enticing ad promotions\n  4. Besides\n  5. Weep loudly\n  6. Lab assistant often depicted with a hunched back\n  7. Name on a mailbox at the North Pole\n  8. ___ the Frog\n  9. Abnormal\n 10. Makes an oopsie\n 11. Washington's M.L.B. team, informally\n 12. ___-squat (a whole lot of nothing)\n 13. Give the heebie-jeebies\n 18. Door opener\n 22. Reeves of \"The Matrix\"\n 24. Go down the slopes with a chute\n 26. Drew funny little pictures\n 28. Lass\n 32. One end to a boxing match, for short\n 34. \"Phew!\"\n 35. Warms up\n 36. \"Gro-o-oss!\"\n 37. Black-and-white dessert that's sliced\n 39. Pot smokers\n 40. Experimental effort\n 41. Pushes down, as with the thumb\n 42. Style for Picasso\n 43. Use TikTok, say\n 45. Spanish newborn\n 46. Small gushes\n 47. Coke and Pepsi, but not Sprite\n 48. Oahu neighbor\n 52. Tickle Me ___\n 55. Sweetie\n 56. One of three in an ellipsis</input>\n    <expected_output>C I T E . S I C K O . S T D S\nA L E X . O G L E D . C H I P\nB L A C K B O A R D . R E D O\nR I S E N . R U M . K E N D O\nI C E P O P . S I D E W A L K\nD I R T B A G . T O A S T Y .\nE T S . . R A T . O N U S . .\n. . . C H A L K E D U P . . .\n. . O L E S . O W L . . S T P\n. C R O A K S . W E B S T E R\nC U E S T I C K . D E P O S E\nO B O E S . R A E . B U N T S\nL I P O . B O U L D E R E R S\nA S I N . A L A M O . T R U E\nS M E E . E L I O T . S S N S\n\nAcross:\n  1. CITE\n  5. SICKO\n 10. STDS\n 14. ALEX\n 15. OGLED\n 16. CHIP\n 17. BLACKBOARD\n 19. REDO\n 20. RISEN\n 21. RUM\n 22. KENDO\n 23. ICEPOP\n 25. SIDEWALK\n 27. DIRTBAG\n 29. TOASTY\n 30. ETS\n 31. RAT\n 33. ONUS\n 34. CHALKEDUP\n 37. OLES\n 38. OWL\n 39. STP\n 42. CROAKS\n 44. WEBSTER\n 47. CUESTICK\n 49. DEPOSE\n 50. OBOES\n 51. RAE\n 53. BUNTS\n 54. LIPO\n 55. BOULDERERS\n 57. ASIN\n 58. ALAMO\n 59. TRUE\n 60. SMEE\n 61. ELIOT\n 62. SSNS\n\nDown:\n  1. CABRIDE\n  2. ILLICIT\n  3. TEASERS\n  4. EXCEPT\n  5. SOB\n  6. IGOR\n  7. CLAUS\n  8. KERMIT\n  9. ODD\n 10. SCREWSUP\n 11. THENATS\n 12. DIDDLY\n 13. SPOOK\n 18. KNOB\n 22. KEANU\n 24. PARASKI\n 26. DOODLED\n 28. GAL\n 32. TKO\n 34. CLOSEONE\n 35. HEATS\n 36. EWW\n 37. OREOPIE\n 39. STONERS\n 40. TESTRUN\n 41. PRESSES\n 42. CUBISM\n 43. SCROLL\n 45. BEBE\n 46. SPURTS\n 47. COLAS\n 48. KAUAI\n 52. ELMO\n 55. BAE\n 56. DOT</expected_output>\n</example-1>\n\nYour goal is to maximize your score on the input below.\nBased on your output, you will get a score from 0 to 1.\nIn the example(s) above, returning <expected-output> would get you a score of 1.\nYour exact response will be shown to the scorer, so don't add any extra information.\n\nINPUT:\n"

def process_input(input_string: str) -> str:
    return execute_llm(PROMPT + input_string)
